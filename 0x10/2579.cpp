/*
1. 테이블 정의하기
D[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값

-> 제약떄문에 안됨

D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값,
단 i번째 계단은 반드시 밟아야 함
i번째 계단을 반드시 밟아야 한다는 조건이 있기 때문에,
j=1 or j=2이다.


2. 점화식 찾기

D[k][1] 현재까지 1개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때의 점수 최댓값

D[k][1] = max(D[k-2][1], D[k-2][2])+arr[k];
D[k][2] = D[k-1][1] + arr[k];

이 문제에서 1차원배열을 이용해서 풀 수도 있다.

-> 밟지 않을 계단을 선택

n번째 계단까지 점수의 최댓값을 구하는 상황은
곧 밟지 않을 계단의 합을 최소로 하면 됨

1. 테이블 정의
D[i] = i번째 계단을 반드시 안 밟는다고 할 때, i번째 계단까지 안 밟는 계단 점수 합의 최솟값

2. 점화식 찾기
D[k] = min(D[k-2], D[k-3])+S[k];

3. 초기값 정하기
D[1] = S[1]
D[2] = S[2]
D[3] = S[3]

sum-min(d[n-1],d[n-2])
*/

#include<bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    int s[301];
    int d[301][2];

    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> s[i];

    if(n==1){
        cout << s[1] << '\n';
        return 0;
        // n==1일때 d[2]~등의 값에 접근하는게 바람직하지 않기 때문
    }
    d[1][1] = s[1];
    d[1][2] = 0;
    d[2][1] = s[2];
    d[2][2] = s[1] + s[2];

    for (int i = 3; i <= n; i++){
        d[i][1] = max(d[i - 2][1], d[i - 2][2]) + s[i];
        d[i][2] = d[i - 1][1] + s[i];
    }

    cout << max(d[n][1], d[n][2]) << '\n';
    return 0;
}