재귀 
: 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

재귀로 문제를 푼다는 것? 귀납적인 방식으로 문제를 푼다는 것

void func1(int n){
    if(n==0) return;
    cout << n << ' ';
    func(n-1);
}

1. 절차지향적인 사고
3출력 -> func1(2)호출 -> 2출력 -> func1(1) 호출 -> 1출력 -> func1(0) 호출 -> 끝

2. 귀납적인 사고

func1(1)이 1을 호출한다.

func1(k)가 k, k-1, ''' 1을 출력하면 func1(k+1)은 k+1, k, ''' 1을 출력한다.
-> 이게 성립하면 우리는 절차지향적인 생각을 하지 않아도 func1(n)이 옳바른 함수라는 것을
알 수 있다.

// 1~n까지 합을 구하는 함수

int func2(int n){
    if(n==0) return 0;
    
    return n + sum(n-1);
}


재귀 함수의 조건
특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함.(Base condition)
모든 입력은 Base condition으로 수렴해야 함.

어느 하나라도 지켜지지 않으면 run time error 발생


재귀에 대한 정보 1

1. 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야함
2. 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
3. 재귀는 반복문으로 구현했을 떄에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄

재귀 없이 구현을 하면 코드가 너무 복잡해지면 재귀를 사용하는게 나음
문제 많이 풀어봐

재귀에 대한 정보 2
한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음

int fib(int n){
    if(n<=1) return 1;

    return fib(n-1) + fib(n-2);
}
시간 복잡도 O(1.618^n);
-> 이미 계산한 값을 또 계산하는 일이 빈번하게 발생함.

재귀에 대한 정보 3
재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨

보통 컴파일 환경에서는 스택 영역의 메모리가 제한 돼 있음. 스택 메모리에는 지역 변수도 들어감
