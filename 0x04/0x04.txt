연결 리스트
-> 원소들을 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조.
원소들은 이곳저곳에 흩어져 있다.

연결 리스트의 성질

1. k번째 원소를 확인/변경하기 위해 O(k)가 필요함

3->13->72-> 에서 72찾고자하면 3,13 순으로 찾아가야함.

2. 임의의 위치에 원소를 추가/제거는 O(1)
 * 연결 리스트의 장점

 3. 원소들이 메모리 상에 연속해있지 않아 cache hit rate가 낮지만 할당이 다소 쉬움


 연결 리스트의 종류

 Singly linked list : 각 원소가 자신의 다음 원소의 주소를 포함하고 있는 연결 리스트
 Double linked list : 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 들고 있는 리스트
  * 메모리를 더 쓴다는 단점이 있다.
 * c++ stl에 list가 있음. container의 이름은 list이고 구조는 double linked list 이다.
Circular linked list : 끝이 처음과 연결돼있음


배열 vs 연결리스트

1. k번째 원소 접근 : O(1) vs O(k)
2. 임의 위치 원소 추가/제거 : O(n) vs O(1)
3. 메모리 상의 배치 : 연속 vs 불연속
4. 추가적으로 필요한 공간 : - vs O(N), linked list에서는 각 원소가 주소값을 가지고 있어야함. 

linked list operation

1. 임의의 위치에 있는 원소를 확인/변경 . O(N)
list의 경우 메모리에 불연속적으로 배치 돼있음.
이때 우리는 list의 첫번째 원소의 주소값만 알기 때문에 임의의 위치에 있는 원소 확인을
위해선 첫번째 원소의 link를 통해 넘어가면서 확인해야 함.

2. 임의의 위치에 원소를 추가, O(1) 단, 추가하고 싶은 위치의 주소를 알고 있을 때만 O(1)
3. 임의 위치 원소 제거 O(1). 이것도 마찬가지로 제거하고 싶은 위치의 주소의 전 원소를 알고있을때만 O(1)

linked list 가 쓰이는 대표적인 상황 : 메모장과 같은 text editor

text editor와 같이 커서를 옮기고, 글자를 지우고 중간에 넣고
등의 다양한 연산을 하고 최종 결과를 출력하라는 식의 문제가 있을 때는 배열보다 linked list가 효율


코테에서는 stl list 를 사용하면 됨. 정석적 구현 방법은 개인 공부


야매 연결 리스트

만약 stl을 사용할 수 없을 땐 빠르게 구현할 수 있는 다음과 같은 것도 고려해보면 좋다.

const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused=1; // 현재 사용하지 않는 index, 즉, 새로운 원소가 들어갈 수 있는 인덱스
  원소 추가되면 1씩 증가

fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);
0번지는 값이 들어가지 않고 시작지를 나타내기 위한 dummy node이다.

void traverse(){
    int cur=nxt[0];
    while(cur!=-1){
        cout << dat[cur] << ' ';
        cur = nxt[cur];
    }

    cout << '\n';
    
}


생각해볼만한 문제
1. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 list의 길이를 효율적으로 구하는 방법?
2. 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법? 
-> 두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구함
그 후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘의 차이만큼 앞으로 먼저 이동시켜놓고
두 시작점이 만날 떄까지 두 시작점을 동시에 한 칸씩 전진시키면 됨. 공간O(1), 시간 O(N+m)

3. 주어진 연결리스트 안에 사이클이 있는지 확인하라.

정답 : Floyd's cycle-finding algorithm, 공간O(1), 시간O(N)
-> 시작점부터 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키고,
사이클이 있을 경우 두 커서는 반드시 만나게 됨. 없으면 만나지 못하고 연결리스트의 끝에 도달
