BFS(Breadth first search)
: 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘

step by step explanation

1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면
방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때까지 2번을 반복
모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)

utility header에 있는 pair 라는 stl
두 자료형을 묶어서 가지고 다닐 수 있음

#include<bits/stdc++.h>


using namespace std;

int main(){
    pair<int, int> t1 = make_pair(10,13);
    pair<int, int> t2 = {4,6}; // C++11
    cout << t2.first << ' ' << t2.second << '\n'; //4 6
    if(t2 < t1) cout << "t2 < t2"; //t2 < t1
}

queue에 좌표를 넣어야 하는데, 이 때 pair를 사용할 것임

// 주의할 점
1. 시작점에 방문했다는 표시를 남기지 않는다.
2. 큐에 넣을 때 방문했다는 표시를 하는 대신 큐에서 빼낼 때 방문했다는 표시를 남겼다.
3. 이웃한 원소가 범위를 벗어났는지에 대한 체크를 잘못했다.

BFS는 코테에 자주 나오는 주제이기 때문에 응용도 모두 잘 이해하고 있어야 한다.

응용 1 - 거리측정
BOJ 2178번
-> 단순히 상하좌우 연결된 칸을 방문하는 것에서 끝나는게 아니라, 
시작점까지의 거리를 전부 계산할 수 있음

응용 2 - 시작점이 여러개일때
BOJ 7576번
여러 개의 시작점에서 모든 지점으로의 거리를 구하는 문제

BFS를 돌 때 queue에 쌓이는 순서는 반드시 거리순이다.

0 0 1 1 1 1 1 2 2 2 3 3 3
